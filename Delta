-- ---------------------------------------------------
-- 1) params: yesterday + tolerance window
-- ---------------------------------------------------
WITH params AS (
  SELECT
    DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) AS report_date,
    15                                 AS tolerance_minutes
),

-- ---------------------------------------------------
-- 2) sched: build expected_run_ts and is_scheduled flag
-- ---------------------------------------------------
sched AS (
  SELECT
    i.act_id                         AS dag_name,
    i.schedinterval                  AS schedule_interval,
    i.schedfreq                      AS schedule_frequency,
    i.schedinit,
    p.report_date,
    p.tolerance_minutes,

    -- build the exact timestamp we expect yesterday’s run
    TIMESTAMP(
      DATETIME(
        p.report_date,
        TIME(
          EXTRACT(HOUR   FROM i.schedinit),
          EXTRACT(MINUTE FROM i.schedinit),
          EXTRACT(SECOND FROM i.schedinit)
        )
      )
    ) AS expected_run_ts,

    -- should it have run on that date?
    CASE i.schedfreq
      WHEN 'd' THEN TRUE
      WHEN 'm' THEN
        EXTRACT(DAY FROM p.report_date) = EXTRACT(DAY FROM i.schedinit)
        AND MOD(
          DATE_DIFF(p.report_date, DATE(i.schedinit), MONTH),
          i.schedinterval
        ) = 0
      WHEN 'y' THEN
        EXTRACT(MONTH FROM p.report_date) = EXTRACT(MONTH FROM i.schedinit)
        AND EXTRACT(DAY   FROM p.report_date) = EXTRACT(DAY   FROM i.schedinit)
        AND MOD(
          DATE_DIFF(p.report_date, DATE(i.schedinit), YEAR),
          i.schedinterval
        ) = 0
      ELSE FALSE
    END AS is_scheduled

  FROM
    `project.dataset.act_info` AS i
  CROSS JOIN
    params           AS p
  WHERE
    DATE(i.schedinit) <= p.report_date
),

-- ---------------------------------------------------
-- 3) execs: grab the most-recent task_start on that date
-- ---------------------------------------------------
execs AS (
  SELECT
    el.dag_id                         AS dag_name,
    MAX(TIMESTAMP(el.task_start_date)) AS last_start_time
  FROM
    `project.dataset.act_exec_log` AS el
  JOIN
    params                      AS p
    ON DATE(TIMESTAMP(el.task_start_date)) = p.report_date
  GROUP BY
    el.dag_id
),

-- ---------------------------------------------------
-- 4) failures: collect any failed task_ids into an ARRAY
-- ---------------------------------------------------
failures AS (
  SELECT
    el.dag_id                     AS dag_name,
    ARRAY_AGG(DISTINCT el.task_id ORDER BY el.task_id) AS failed_tasks
  FROM
    `project.dataset.act_exec_log` AS el
  JOIN
    params                       AS p
    ON DATE(TIMESTAMP(el.task_start_date)) = p.report_date
  WHERE
    el.task_state = 'failed'
  GROUP BY
    el.dag_id
),

-- ---------------------------------------------------
-- 5) combine & classify, now including failed_tasks
-- ---------------------------------------------------
reports AS (
  SELECT
    s.dag_name,
    s.report_date                  AS scheduled_date,
    s.expected_run_ts,
    e.last_start_time,
    f.failed_tasks,

    CASE
      WHEN NOT s.is_scheduled THEN '– Not Scheduled Yesterday'
      WHEN e.last_start_time IS NULL THEN '❌ Missed Run'
      WHEN f.failed_tasks IS NOT NULL THEN '❌ Failed Tasks'
      WHEN e.last_start_time
           BETWEEN
             TIMESTAMP_SUB(s.expected_run_ts, INTERVAL s.tolerance_minutes MINUTE)
           AND
             TIMESTAMP_ADD(s.expected_run_ts, INTERVAL s.tolerance_minutes MINUTE)
        THEN '✅ Ran On Time'
      ELSE '⚠️ Ran Off Time'
    END AS run_status,

    -- how many seconds early/late (null if missed or not scheduled)
    CASE
      WHEN e.last_start_time IS NOT NULL
      THEN TIMESTAMP_DIFF(e.last_start_time, s.expected_run_ts, SECOND)
    END AS deviation_seconds

  FROM
    sched AS s
  LEFT JOIN
    execs     AS e USING(dag_name)
  LEFT JOIN
    failures  AS f USING(dag_name)
)

SELECT
  dag_name,
  scheduled_date,
  expected_run_ts,
  last_start_time,
  deviation_seconds,
  run_status,
  failed_tasks
FROM
  reports
ORDER BY
  dag_name;
